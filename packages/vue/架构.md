对接命名空间内 packages/parser 相关模块

# hook设计

- WorkerPoll相关hook
- 单线程的Worker相关hook
  这里指的是使用parser中WorkerPoll版本 / 普通版本。而不是hook内创建worker
  hook接受响应式字符，通过parser转换为，mast。mast通过 “hast-util-to-jsx-runtime” 转换为jsxruntime
- 注意防抖（可能出现连续输入。）设计一个dynamic属性。动态的就需要防抖。就代表内容经常变。

# 导出组件设计

使用上面设计的hooks

支持WorkerPoll组件 <MarkdownWorkerPoll

- 需要使用外层组件来管理(类似于react的Privider，填写线程数和配置)
- 然后再使用子组件渲染(如果不使用MarkdownWorkerPoll的话, 就是单线程Worker)

- 子组件和WorkerPoll管理Privider都能填写渲染相关配置。但是, 使用了MarkdownWorkerPoll填写渲染配置的话，
- 子组件的MarkdownRenderer相关属性就会失效(所以子组件那些配置都是存在默认配置-方便不写)

- 组件被销毁需要释放线程

- 渲染中需要有loading(自行使用svg动态)
- 渲染如果报错，组件需要做错误边界。给提醒.

渲染组件 & MarkdownWorkerPoll 需要支持这样的api能够用户自行替换渲染节点

```
 <MarkdownRenderer
  components={{
    // Map `h1` (`# heading`) to use `h2`s.
    h1: 'h2',
    // Rewrite `em`s (`*like so*`) to `i` with a red foreground color.
    em(props) {
      const {node, ...rest} = props
      return <i style={{color: 'red'}} {...rest} />
    }
  }}
/>
```

- 组件自己默认渲染节点的行内样式使用： theme-github 主题
- 需要支持自定义渲染code。方便用户使用（highlight.js）进行自定义组件渲染。
- 数学公式不支持自定义渲染（mathjax）

## 运行时关系 / 转换关系

- parser转换输出hast。
- hast通过 “hast-util-to-jsx-runtime” 转换为jsxruntime => 通过h函数（vite的编译器）转换为Vue Vnode
  编写的vue组件形式一定都是.tsx的形式

# 打包工具

请使用vite。相关的jsx插件请自行配置

# 检查

编写途中一定要建立eslint和tscconfig（基于仓库repo的base）和vue使用eslint严格模式编写校验

# 注意事项

- 转换过程中一定要确保mathjax节点的正确渲染
- vue的版本3.2及以上（package.json中进行约束）
- MarkdownRenderer 外层没有嵌套 MarkdownWorkerPoll 的话，一个组件（对应的单线程hook）就是一个Woker线程（对应parser中的单worker线程）。线程溢出风险是用户的责任，不用管理。
